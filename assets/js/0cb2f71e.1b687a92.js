"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[60288],{73304:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"4.5","label":"4.5","banner":"unmaintained","badge":true,"noIndex":false,"className":"docs-version-4.5","isLast":false,"docsSidebars":{"version-4.5/docs":[{"collapsed":true,"type":"category","label":"Overview","items":[{"type":"link","label":"Installation & Usage","href":"/docs/4.5/installation","docId":"installation"},{"type":"link","label":"Defining Entities","href":"/docs/4.5/defining-entities","docId":"defining-entities"},{"type":"link","label":"Modeling Entity Relationships","href":"/docs/4.5/relationships","docId":"relationships"},{"type":"link","label":"Entity Manager","href":"/docs/4.5/entity-manager","docId":"entity-manager"},{"type":"link","label":"Unit of Work","href":"/docs/4.5/unit-of-work","docId":"unit-of-work"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Fundamentals","items":[{"type":"link","label":"Identity Map and Request Context","href":"/docs/4.5/identity-map","docId":"identity-map"},{"type":"link","label":"Entity References and Reference<T> Wrapper","href":"/docs/4.5/entity-references","docId":"entity-references"},{"type":"link","label":"Collections","href":"/docs/4.5/collections","docId":"collections"},{"type":"link","label":"Entity Repository","href":"/docs/4.5/repositories","docId":"repositories"},{"type":"link","label":"Transactions and Concurrency","href":"/docs/4.5/transactions","docId":"transactions"},{"type":"link","label":"Inheritance Mapping","href":"/docs/4.5/inheritance-mapping","docId":"inheritance-mapping"},{"type":"link","label":"Cascading","href":"/docs/4.5/cascading","docId":"cascading"},{"type":"link","label":"Filters","href":"/docs/4.5/filters","docId":"filters"},{"type":"link","label":"Deployment","href":"/docs/4.5/deployment","docId":"deployment"},{"type":"link","label":"Using Query Builder","href":"/docs/4.5/query-builder","docId":"query-builder"},{"type":"link","label":"Result cache","href":"/docs/4.5/caching","docId":"caching"},{"type":"link","label":"Logging","href":"/docs/4.5/debugging","docId":"debugging"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Advanced Features","items":[{"type":"link","label":"Smart Nested Populate","href":"/docs/4.5/nested-populate","docId":"nested-populate"},{"type":"link","label":"Smart Query Conditions","href":"/docs/4.5/query-conditions","docId":"query-conditions"},{"type":"link","label":"Propagation","href":"/docs/4.5/propagation","docId":"propagation"},{"type":"link","label":"Loading Strategies","href":"/docs/4.5/loading-strategies","docId":"loading-strategies"},{"type":"link","label":"Serializing","href":"/docs/4.5/serializing","docId":"serializing"},{"type":"link","label":"Updating Entity Values","href":"/docs/4.5/entity-helper","docId":"entity-helper"},{"type":"link","label":"Hooks and Events","href":"/docs/4.5/lifecycle-hooks","docId":"lifecycle-hooks"},{"type":"link","label":"Composite Primary Keys","href":"/docs/4.5/composite-keys","docId":"composite-keys"},{"type":"link","label":"Custom Types","href":"/docs/4.5/custom-types","docId":"custom-types"},{"type":"link","label":"Embeddables","href":"/docs/4.5/embeddables","docId":"embeddables"},{"type":"link","label":"Defining Entities via EntitySchema","href":"/docs/4.5/entity-schema","docId":"entity-schema"},{"type":"link","label":"Using JSON properties","href":"/docs/4.5/json-properties","docId":"json-properties"},{"type":"link","label":"Metadata Providers","href":"/docs/4.5/metadata-providers","docId":"metadata-providers"},{"type":"link","label":"Metadata Cache","href":"/docs/4.5/metadata-cache","docId":"metadata-cache"},{"type":"link","label":"Schema Generator","href":"/docs/4.5/schema-generator","docId":"schema-generator"},{"type":"link","label":"Entity Generator","href":"/docs/4.5/entity-generator","docId":"entity-generator"},{"type":"link","label":"Naming Strategy","href":"/docs/4.5/naming-strategy","docId":"naming-strategy"},{"type":"link","label":"Property Validation","href":"/docs/4.5/property-validation","docId":"property-validation"},{"type":"link","label":"Migrations","href":"/docs/4.5/migrations","docId":"migrations"},{"type":"link","label":"Read Replica Connections","href":"/docs/4.5/read-connections","docId":"read-connections"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Reference","items":[{"type":"link","label":"EntityManager API","href":"/api/core/class/EntityManager"},{"type":"link","label":"EntityRepository API","href":"/api/core/class/EntityRepository"},{"type":"link","label":"QueryBuilder API","href":"/api/knex/class/QueryBuilder"},{"type":"link","label":"Decorators","href":"/docs/4.5/decorators","docId":"decorators"},{"type":"link","label":"Configuration","href":"/docs/4.5/configuration","docId":"configuration"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Usage with Different Drivers","items":[{"type":"link","label":"Usage with SQL Drivers","href":"/docs/4.5/usage-with-sql","docId":"usage-with-sql"},{"type":"link","label":"Usage with MongoDB","href":"/docs/4.5/usage-with-mongo","docId":"usage-with-mongo"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Recipes","items":[{"type":"link","label":"Quick Start","href":"/docs/4.5/quick-start","docId":"quick-start"},{"type":"link","label":"Usage with NestJS","href":"/docs/4.5/usage-with-nestjs","docId":"usage-with-nestjs"},{"type":"link","label":"Usage with Vanilla JS","href":"/docs/4.5/usage-with-js","docId":"usage-with-js"},{"type":"link","label":"Usage with Babel","href":"/docs/4.5/usage-with-babel","docId":"usage-with-babel"},{"type":"link","label":"Usage with AdminJS","href":"/docs/4.5/usage-with-adminjs","docId":"usage-with-adminjs"},{"type":"link","label":"Using Entity Constructors","href":"/docs/4.5/entity-constructors","docId":"entity-constructors"},{"type":"link","label":"Using Multiple Schemas","href":"/docs/4.5/multiple-schemas","docId":"multiple-schemas"},{"type":"link","label":"Using native BigInt PKs (MySQL and PostgreSQL)","href":"/docs/4.5/using-bigint-pks","docId":"using-bigint-pks"},{"type":"link","label":"Using AsyncLocalStorage","href":"/docs/4.5/async-local-storage","docId":"async-local-storage"},{"type":"link","label":"Creating Custom Driver","href":"/docs/4.5/custom-driver","docId":"custom-driver"}],"collapsible":true},{"collapsed":true,"type":"category","label":"Example Integrations","items":[{"type":"link","label":"Express + MongoDB + TypeScript","href":"https://github.com/mikro-orm/express-ts-example-app"},{"type":"link","label":"NestJS + MySQL + TypeScript","href":"https://github.com/mikro-orm/nestjs-example-app"},{"type":"link","label":"RealWorld example app (Nest + MySQL)","href":"https://github.com/mikro-orm/nestjs-realworld-example-app"},{"type":"link","label":"Express + MongoDB + JavaScript","href":"https://github.com/mikro-orm/express-js-example-app"},{"type":"link","label":"Koa + SQLite + TypeScript","href":"https://github.com/mikro-orm/koa-ts-example-app"},{"type":"link","label":"Inversify + PostgreSQL","href":"https://github.com/PodaruDragos/inversify-example-app"},{"type":"link","label":"NextJS + MySQL","href":"https://github.com/jonahallibone/mikro-orm-nextjs"},{"type":"link","label":"GraphQL + PostgreSQL + TypeScript","href":"https://github.com/driescroons/mikro-orm-graphql-example"}],"collapsible":true}]},"docs":{"async-local-storage":{"id":"async-local-storage","title":"Using AsyncLocalStorage","description":"By default, the domain api is used in the RequestContext helper. Since v4.0.3,","sidebar":"version-4.5/docs"},"caching":{"id":"caching","title":"Result cache","description":"MikroORM has simple result caching mechanism. It works with those methods of","sidebar":"version-4.5/docs"},"cascading":{"id":"cascading","title":"Cascading persist, merge and remove","description":"From v4.2, cascade merging is no longer configurable (and is kept enabled for all relations).","sidebar":"version-4.5/docs"},"collections":{"id":"collections","title":"Collections","description":"OneToMany and ManyToMany collections are stored in a Collection wrapper. It implements","sidebar":"version-4.5/docs"},"composite-keys":{"id":"composite-keys","title":"Composite and Foreign Keys as Primary Key","description":"Support for composite keys was added in version 3.5","sidebar":"version-4.5/docs"},"configuration":{"id":"configuration","title":"Configuration","description":"Entity Discovery","sidebar":"version-4.5/docs"},"custom-driver":{"id":"custom-driver","title":"Creating Custom Driver","description":"If you want to use database that is not currently supported, you can implement your own driver.","sidebar":"version-4.5/docs"},"custom-types":{"id":"custom-types","title":"Custom Types","description":"You can define custom types by extending Type abstract class. It has several optional methods:","sidebar":"version-4.5/docs"},"debugging":{"id":"debugging","title":"Logging","description":"For development purposes it might come handy to enable logging and debug mode:","sidebar":"version-4.5/docs"},"decorators":{"id":"decorators","title":"Decorators","description":"Entity Definition","sidebar":"version-4.5/docs"},"defining-entities":{"id":"defining-entities","title":"Defining Entities","description":"Entities are simple javascript objects (so called POJO) without restrictions and without the need to extend base classes. Using entity constructors works as well - they are never executed for managed entities (loaded from database).","sidebar":"version-4.5/docs"},"deployment":{"id":"deployment","title":"Deployment","description":"Under the hood, MikroORM uses ts-morph to read","sidebar":"version-4.5/docs"},"embeddables":{"id":"embeddables","title":"Separating Concerns using Embeddables","description":"Support for embeddables was added in version 4.0","sidebar":"version-4.5/docs"},"entity-constructors":{"id":"entity-constructors","title":"Using Entity Constructors","description":"Internally, MikroORM never calls entity constructor, so you are free to use it as you wish.","sidebar":"version-4.5/docs"},"entity-generator":{"id":"entity-generator","title":"Entity Generator","description":"To generate entities from existing database schema, you can use EntityGenerator helper.","sidebar":"version-4.5/docs"},"entity-helper":{"id":"entity-helper","title":"EntityHelper and Decorated Entities","description":"Updating Entity Values with entity.assign()","sidebar":"version-4.5/docs"},"entity-manager":{"id":"entity-manager","title":"Working with Entity Manager","description":"Persist and Flush","sidebar":"version-4.5/docs"},"entity-manager-api":{"id":"entity-manager-api","title":"EntityManager API","description":"getDriver(): IDatabaseDriver"},"entity-references":{"id":"entity-references","title":"Entity References","description":"Every single entity relation is mapped to an entity reference. Reference is an entity that has","sidebar":"version-4.5/docs"},"entity-schema":{"id":"entity-schema","title":"Defining Entities via EntitySchema","description":"With EntitySchema helper you define the schema programmatically.","sidebar":"version-4.5/docs"},"faq":{"id":"faq","title":"Frequently Asked Questions","description":"How can I synchronize my database schema with the entities?"},"filters":{"id":"filters","title":"Filters","description":"MikroORM has the ability to pre-define filter criteria and attach those filters","sidebar":"version-4.5/docs"},"identity-map":{"id":"identity-map","title":"Identity Map and Request Context","description":"MikroORM uses identity map in background so you will always get the same instance of","sidebar":"version-4.5/docs"},"inheritance-mapping":{"id":"inheritance-mapping","title":"Inheritance Mapping","description":"Mapped Superclasses","sidebar":"version-4.5/docs"},"installation":{"id":"installation","title":"Installation & Usage","description":"First install the module via yarn or npm and do not forget to install the","sidebar":"version-4.5/docs"},"json-properties":{"id":"json-properties","title":"Using JSON properties","description":"Defining JSON properties","sidebar":"version-4.5/docs"},"lifecycle-hooks":{"id":"lifecycle-hooks","title":"Lifecycle Hooks and EventSubscriber","description":"There are two ways to hook to the lifecycle of an entity:","sidebar":"version-4.5/docs"},"loading-strategies":{"id":"loading-strategies","title":"Relationship Loading Strategies","description":"JOINED loading strategy is SQL only feature.","sidebar":"version-4.5/docs"},"metadata-cache":{"id":"metadata-cache","title":"Metadata Cache","description":"In v4 you need to explicitly install @mikro-orm/reflection to use TsMorphMetadataProvider.","sidebar":"version-4.5/docs"},"metadata-providers":{"id":"metadata-providers","title":"Metadata Providers","description":"As part of entity discovery process, MikroORM uses so called MetadataProvider to get necessary","sidebar":"version-4.5/docs"},"migrations":{"id":"migrations","title":"Migrations","description":"To use migrations we need to first install @mikro-orm/migrations package.","sidebar":"version-4.5/docs"},"multiple-schemas":{"id":"multiple-schemas","title":"Using Multiple Schemas","description":"In MySQL and PostgreSQL it is possible to define your entities in multiple schemas. In MySQL","sidebar":"version-4.5/docs"},"naming-strategy":{"id":"naming-strategy","title":"Naming Strategy","description":"When mapping your entities to database tables and columns, their names will be defined by naming","sidebar":"version-4.5/docs"},"nested-populate":{"id":"nested-populate","title":"Smart Nested Populate","description":"MikroORM is capable of loading large nested structures while maintaining good","sidebar":"version-4.5/docs"},"propagation":{"id":"propagation","title":"Propagation","description":"By default MikroORM will propagate all changes made to one side of bi-directional relations","sidebar":"version-4.5/docs"},"property-validation":{"id":"property-validation","title":"Property Validation","description":"Since v4.0.3 the validation needs to be explicitly enabled via validate: true.","sidebar":"version-4.5/docs"},"query-builder":{"id":"query-builder","title":"Using Query Builder","description":"Since v4, we need to make sure we are working with correctly typed EntityManager","sidebar":"version-4.5/docs"},"query-builder-api":{"id":"query-builder-api","title":"Query Builder API","description":"QueryBuilder provides fluent interface with these methods:"},"query-conditions":{"id":"query-conditions","title":"Smart Query Conditions","description":"When you want to make complex queries, you can easily end up with a lot of boilerplate code","sidebar":"version-4.5/docs"},"quick-start":{"id":"quick-start","title":"Quick Start","description":"First install the module via yarn or npm and do not forget to install the","sidebar":"version-4.5/docs"},"read-connections":{"id":"read-connections","title":"Read Replica Connections","description":"Users can specify multiple read connections via replicas option. You can provide only fields","sidebar":"version-4.5/docs"},"relationships":{"id":"relationships","title":"Modeling Entity Relationships","description":"There are 4 types of entity relationships in MikroORM:","sidebar":"version-4.5/docs"},"repositories":{"id":"repositories","title":"Using EntityRepository instead of EntityManager","description":"More convenient way of fetching entities from database is by using EntityRepository, that","sidebar":"version-4.5/docs"},"repositories-api":{"id":"repositories-api","title":"EntityRepository API","description":"find(where FindOptions): Promise"},"schema-generator":{"id":"schema-generator","title":"Schema Generator","description":"SchemaGenerator can do harm to your database. It will drop or alter tables, indexes,","sidebar":"version-4.5/docs"},"serializing":{"id":"serializing","title":"Serializing","description":"By default, all entities are monkey patched with toObject() and toJSON methods:","sidebar":"version-4.5/docs"},"transactions":{"id":"transactions","title":"Transactions and Concurrency","description":"Starting v3.4, transactions are also supported in MongoDB driver.","sidebar":"version-4.5/docs"},"unit-of-work":{"id":"unit-of-work","title":"Unit of Work and Transactions","description":"MikroORM uses the Identity Map pattern to track objects. Whenever you fetch an object from","sidebar":"version-4.5/docs"},"upgrading-v2-to-v3":{"id":"upgrading-v2-to-v3","title":"Upgrading from v2 to v3","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid"},"upgrading-v3-to-v4":{"id":"upgrading-v3-to-v4","title":"Upgrading from v3 to v4","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid"},"upgrading-v4-to-v5":{"id":"upgrading-v4-to-v5","title":"Upgrading from v4 to v5","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid"},"usage-with-adminjs":{"id":"usage-with-adminjs","title":"Using MikroORM with AdminJS","description":"Installation","sidebar":"version-4.5/docs"},"usage-with-babel":{"id":"usage-with-babel","title":"Usage with Babel","description":"When compiling TS via babel, decorators are by default handled different implementation","sidebar":"version-4.5/docs"},"usage-with-js":{"id":"usage-with-js","title":"Usage with JavaScript","description":"Since MikroORM 3.2, we can use EntitySchema helper to define own entities without","sidebar":"version-4.5/docs"},"usage-with-mongo":{"id":"usage-with-mongo","title":"Usage with MongoDB","description":"To use MikroORM with mongo database, do not forget to install @mikro-orm/mongodb","sidebar":"version-4.5/docs"},"usage-with-nestjs":{"id":"usage-with-nestjs","title":"Using MikroORM with NestJS framework","description":"Installation","sidebar":"version-4.5/docs"},"usage-with-sql":{"id":"usage-with-sql","title":"Usage with MySQL, MariaDB, PostgreSQL or SQLite","description":"To use mikro-orm with MySQL database, simply install the @mikro-orm/mysql dependency and set","sidebar":"version-4.5/docs"},"using-bigint-pks":{"id":"using-bigint-pks","title":"Using native BigInt PKs (MySQL and PostgreSQL)","description":"You can use BigIntType to support bigints. By default it will represent the value as","sidebar":"version-4.5/docs"}}}')}}]);