"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[93706],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(a),d=r,h=c["".concat(l,".").concat(d)]||c[d]||m[d]||o;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},37858:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return s},metadata:function(){return u},toc:function(){return m}});var n=a(83117),r=a(80102),o=(a(67294),a(3905)),i=["components"],s={slug:"mikro-orm-4-released",title:"MikroORM 4: Filling the Gaps",author:"Martin Ad\xe1mek",authorTitle:"Author of MikroORM",authorURL:"https://github.com/B4nan",authorImageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4",authorTwitter:"B4nan",tags:["typescript","javascript","node","sql"]},l=void 0,u={permalink:"/blog/mikro-orm-4-released",source:"@site/blog/2020-09-08-mikro-orm-4-released.md",title:"MikroORM 4: Filling the Gaps",description:"After 4 months of active development, I am thrilled to announce the release of MikroORM 4. When I started to work on v4, the goal was to make it relatively small release, mainly to drop support for TypeScript 3.6 and Node.js 8, and to split the project into multiple packages, so we can have more fine grained control over the dependencies (mainly because of ts-morph having TS as a runtime dependency).",date:"2020-09-08T00:00:00.000Z",formattedDate:"September 8, 2020",tags:[{label:"typescript",permalink:"/blog/tags/typescript"},{label:"javascript",permalink:"/blog/tags/javascript"},{label:"node",permalink:"/blog/tags/node"},{label:"sql",permalink:"/blog/tags/sql"}],readingTime:12.695,hasTruncateMarker:!0,authors:[{name:"Martin Ad\xe1mek",title:"Author of MikroORM",url:"https://github.com/B4nan",imageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4"}],frontMatter:{slug:"mikro-orm-4-released",title:"MikroORM 4: Filling the Gaps",author:"Martin Ad\xe1mek",authorTitle:"Author of MikroORM",authorURL:"https://github.com/B4nan",authorImageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4",authorTwitter:"B4nan",tags:["typescript","javascript","node","sql"]},prevItem:{title:"MikroORM 4.1: Let\u2019s talk about performance",permalink:"/blog/mikro-orm-4-1-released"},nextItem:{title:"MikroORM 3: Knex.js, CLI, Schema Updates, Entity Generator and\xa0more\u2026",permalink:"/blog/mikro-orm-3-released"}},p={authorsImageUrls:[void 0]},m=[{value:"In case you don\u2019t know\u2026",id:"in-case-you-dont-know",level:3},{value:"Quick summary of 3.x releases",id:"quick-summary-of-3x-releases",level:3},{value:"Monorepo",id:"monorepo",level:3},{value:"Filters",id:"filters",level:3},{value:"Global Filters",id:"global-filters",level:4},{value:"EventSubscribers and flush events",id:"eventsubscribers-and-flush-events",level:3},{value:"Flush events",id:"flush-events",level:4},{value:"Joined loading strategy",id:"joined-loading-strategy",level:3},{value:"Single Table Inheritance",id:"single-table-inheritance",level:3},{value:"Embeddables",id:"embeddables",level:3},{value:"Lazy scalar properties",id:"lazy-scalar-properties",level:3},{value:"Computed Properties",id:"computed-properties",level:3},{value:"Type-safe references",id:"type-safe-references",level:3},{value:"QueryBuilder improvements",id:"querybuilder-improvements",level:3},{value:"And many many more\u2026",id:"and-many-many-more",level:3},{value:"More example integrations",id:"more-example-integrations",level:4},{value:"Upgrading",id:"upgrading",level:3},{value:"What\u2019s next?",id:"whats-next",level:3},{value:"WDYT?",id:"wdyt",level:3}],c={toc:m};function d(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"After 4 months of active development, I am thrilled to announce the release of ",(0,o.kt)("a",{parentName:"p",href:"http://github.com/mikro-orm/mikro-orm"},"MikroORM 4"),". When I started to work on v4, the goal was to make it relatively small release, mainly to drop support for TypeScript 3.6 and Node.js 8, and to split the project into multiple packages, so we can have more fine grained control over the dependencies (mainly because of ts-morph having TS as a runtime dependency)."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"But what a major release would that be, without having a bunch of new features as well, right?")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/1024/0*JU7VN0bgkL57RnZJ",alt:"Photo by Ryoji Iwata on Unsplash"})),(0,o.kt)("h3",{id:"in-case-you-dont-know"},"In case you don\u2019t know\u2026"),(0,o.kt)("p",null,"If you never heard of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm"},"MikroORM"),", it\u2019s a TypeScript data-mapper ORM with Unit of Work and Identity Map. It supports MongoDB, MySQL, PostgreSQL and SQLite drivers currently. Key features of the ORM are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/mikro-orm#implicit-transactions"},"Implicit transactions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/mikro-orm#changeset-based-persistence"},"ChangeSet based persistence")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/identity-map/"},"Identity map"))),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/1024/0*VEfH0Y8e_cMVXad1.png",alt:null})),(0,o.kt)("p",null,"You can read the full ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02"},"introductory article here")," or ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/"},"browse through the docs"),"."),(0,o.kt)("h3",{id:"quick-summary-of-3x-releases"},"Quick summary of 3.x releases"),(0,o.kt)("p",null,"Before I dive into all the things v4, let\u2019s recap the major features that landed in 3.x releases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/entity-schema"},"Defining entities via"),(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/entity-schema"},"EntitySchema")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/propagation"},"Propagation of changes to m:1/1:1 to inverse sides")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/usage-with-mongo#transactions"},"Transactions in MongoDB")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/composite-keys"},"Composite primary keys"))),(0,o.kt)("h3",{id:"monorepo"},"Monorepo"),(0,o.kt)("p",null,"The first major change I want to talk about is the split into multiple packages. As mentioned above, the biggest motivation for this change was to get rid of TS as a runtime dependency, when it is not needed. Another nice example is knex, which is used as a base layer for SQL driver, but has no meaning for mongodb users. Lastly, it turned out Highlight.js, that was used for query highlighting, is also quite fat and slow, so I ended up writing custom highlighters that are built for CLI and are (almost) dependency free."),(0,o.kt)("p",null,"In v4, there are 12 packages and 2 highlighters, you install only what you use, and you have control over what is needed in production and what is just a dev dependency. This is especially useful for serverless users, where cold start speeds matter."),(0,o.kt)("p",null,"It felt natural to offer some shortcuts on the EntityManager and EntityRepository level, so we now have flavours of those classes in place, that offer things like em.execute(sql) or em.aggregate(). To access those driver specific methods, be sure to use the classes from driver packages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package\n\nconst em: EntityManager;\nconst qb = await em.createQueryBuilder(\u2026); // or `em.execute()`, `em.getKnex()`, ...\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Database connectors like pg or sqlite3 are now dependencies of the driver packages (e. g. @mikro-orm/sqlite).")),(0,o.kt)("h3",{id:"filters"},"Filters"),(0,o.kt)("p",null,"Probably the most interesting feature of v4 are ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/filters/"},"filters"),", also known as association scopes. They allow you to define data visibility rules, both global and bound to entity. One common application of filters are soft deletes, or automatic tenant conditions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\n@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })\n@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })\n@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })\n@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })\nexport class Book {\n  ...\n}\n\nconst books1 = await orm.em.find(Book, {}, {\n  filters: ['long', 'expensive'],\n});\nconst books2 = await orm.em.find(Book, {}, {\n  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },\n});\n")),(0,o.kt)("p",null,"Filters are applied to those methods of EntityManager: find(), findOne(), findAndCount(), findOneOrFail(), count(), nativeUpdate() and nativeDelete(). Filters can be parametric, the parameter can be also in form of callback (possibly async). You can also make the filter enabled by default."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Filter can be defined at the entity level, dynamically via EM (global filters) or in the ORM configuration.")),(0,o.kt)("h4",{id:"global-filters"},"Global Filters"),(0,o.kt)("p",null,"We can also register filters dynamically via EntityManager API. We call such filters global. They are enabled by default (unless disabled via last parameter in addFilter() method), and applied to all entities. You can limit the global filter to only specified entities."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Filters as well as filter params set on the EM will be copied to all its forks."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// bound to entity, enabled by default\nem.addFilter('writtenBy', args => ({ author: args.id }), Book);\n\n// global, enabled by default, for all entities\nem.addFilter('tenant', args => { ... });\n\n// global, enabled by default, for only specified entities\nem.addFilter('tenant', args => { ... }, [Author, Book]);\n...\n\n// set params (probably in some middleware)\nem.setFilterParams('tenant', { tenantId: 123 });\nem.setFilterParams('writtenBy', { id: 321 });\n")),(0,o.kt)("h3",{id:"eventsubscribers-and-flush-events"},"EventSubscribers and flush events"),(0,o.kt)("p",null,"As opposed to regular lifecycle hooks, we can now use ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/lifecycle-hooks/#eventsubscriber"},"EventSubscriber")," to hook to multiple entities or if you do not want to pollute the entity prototype. All methods are optional, if you omit the getSubscribedEntities() method, it means you are subscribing to all entities."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { EntityName, EventArgs, EventSubscriber, Subscriber } from '@mikro-orm/core';\n\n@Subscriber()\nexport class AuthorSubscriber implements EventSubscriber<Author> {\n\n  getSubscribedEntities(): EntityName<Author>[] {\n    return [Author];\n  }\n\n  async afterCreate(args: EventArgs<Author>): Promise<void> {\n    // ...\n  }\n\n  async afterUpdate(args: EventArgs<Author>): Promise<void> {\n    // ... \n  }\n\n}\n")),(0,o.kt)("h4",{id:"flush-events"},"Flush events"),(0,o.kt)("p",null,"There is a ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/lifecycle-hooks/#flush-events"},"special kind of events")," executed during the commit phase (flush operation). They are executed before, during and after the flush, and they are not bound to any entity in particular."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"beforeFlush is executed before change sets are computed, this is the only event where it is safe to persist new entities."),(0,o.kt)("li",{parentName:"ul"},"onFlush is executed after the change sets are computed."),(0,o.kt)("li",{parentName:"ul"},"afterFlush is executed as the last step just before the flush call resolves. it will be executed even if there are no changes to be flushed.")),(0,o.kt)("p",null,"Flush event args will not contain any entity instance, as they are entity agnostic. They do contain additional reference to the UnitOfWork instance."),(0,o.kt)("p",null,"Following example demonstrates the hidden power of flush events\u200a\u2014\u200athey allow to hook into the change set tracking, adjusting what will be persisted and how. Here we try to find a CREATE change set for entity FooBar, and if there is any, we automatically create a new FooBaz entity, connecting it to the FooBar one. This kind of operations was previously impossible, as in regular lifecycle hooks we can only adjust the entity that triggers the event."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Subscriber()\nexport class FooBarSubscriber implements EventSubscriber {\n\n  async onFlush(args: FlushEventArgs): Promise<void> {\n    const changeSets = args.uow.getChangeSets();\n    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);\n\n    if (cs) {\n      const baz = new FooBaz();\n      baz.name = 'dynamic';\n      cs.entity.baz = baz;\n      args.uow.computeChangeSet(baz);\n      args.uow.recomputeSingleChangeSet(cs.entity);\n    }\n  }\n\n}\n\nconst bar = new FooBar();\nbar.name = 'bar';\nawait em.persistAndFlush(bar);\n")),(0,o.kt)("h3",{id:"joined-loading-strategy"},"Joined loading strategy"),(0,o.kt)("p",null,"Loading of complex relations now support so called ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/loading-strategies/"},"JOINED strategy"),". Its name is quite self-explanatory\u200a\u2014\u200ainstead of the default (SELECT","_","IN) strategy, it uses single SQL query and maps the result to multiple entities."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// with the default SELECT_IN strategy, following will issue 2 queries\nconst author = await orm.em.findOne(Author, 1, { populate: ['books'] });\n\n// select * from author where id = 1;\n// select * from book where author_id in (1);\n\n// we can now use JOINED strategy to use a single query\nconst author = await orm.em.findOne(Author, 1, { populate: ['books'], strategy: LoadStrategy.JOINED });\n\n// select a.*, b.* from author a left join book b on b.author_id = a.id where a.id = 1;\n")),(0,o.kt)("h3",{id:"single-table-inheritance"},"Single Table Inheritance"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/inheritance-mapping/#single-table-inheritance"},"STI is an inheritance mapping strategy")," where all classes of a hierarchy are mapped to a single database table. In order to distinguish which row represents which type in the hierarchy a so-called discriminator column is used."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If no discriminator map is provided, it will be generated automatically.")),(0,o.kt)("p",null,"Following example defines 3 entities\u200a\u2014\u200athey will all be stored in a single database table called person, with a special column named type, that will be used behind the scenes to know what class should be used to represent given row/entity."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity({\n  discriminatorColumn: 'type',\n  discriminatorMap: { person: 'Person', employee: 'Employee', owner: 'Owner' },\n})\nexport class Person {\n  // \u2026\n}\n\n@Entity()\nexport class Employee extends Person {\n  // \u2026\n}\n\n@Entity()\nexport class Owner extends Person {\n  // \u2026\n}\n")),(0,o.kt)("h3",{id:"embeddables"},"Embeddables"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/embeddables/"},"Embeddables")," are classes which are not entities themselves, but are embedded in entities and can also be queried. You\u2019ll mostly want to use them to reduce duplication or separating concerns. Value objects such as date range or address are the primary use case for this feature."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Embeddables can only contain properties with basic @Property() mapping.")),(0,o.kt)("p",null,"Following example will result in a single database table, where the address fields will be inlined (with prefix) to the user table."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class User {\n\n  @Embedded()\n  address!: Address;\n\n}\n\n@Embeddable()\nexport class Address {\n  \n  @Property()\n  street!: string;\n\n  @Property()\n  postalCode!: string;\n\n  @Property()\n  city!: string;\n\n  @Property()\n  country!: string;\n\n}\n")),(0,o.kt)("h3",{id:"lazy-scalar-properties"},"Lazy scalar properties"),(0,o.kt)("p",null,"In MikroORM 4, we can mark any property as ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/defining-entities#lazy-scalar-properties"},"lazy: true")," to omit it from the select clause. This can be handy for properties that are too large and you want to have them available only some times, like a full text of an article."),(0,o.kt)("p",null,"When we need such value, we can use populate parameter to load it as if it was a reference."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If the entity is already loaded and you need to populate a lazy scalar property, you might need to pass refresh: true in the FindOptions.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Book {\n\n  @Property({ columnType: 'text', lazy: true })\n  text: string;\n\n}\n\nconst b1 = await em.find(Book, 1); // this will omit the `text` property\nconst b2 = await em.find(Book, 1, { populate: ['text'] }); // this will load the `text` property\n")),(0,o.kt)("h3",{id:"computed-properties"},"Computed Properties"),(0,o.kt)("p",null,"Another small enhancement in entity definition is the ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/defining-entities/#formulas"},"@Formula() decorator"),". It can be used to map some SQL snippet to your entity. The SQL fragment can be as complex as you want and even include subselects."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Box {\n\n  @Formula('obj_length * obj_height * obj_width')\n  objectVolume?: number;\n\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Formulas will be added to the select clause automatically. In case you are facing problems with NonUniqueFieldNameException, you can define the formula as a callback that will receive the entity alias in the parameter.")),(0,o.kt)("h3",{id:"type-safe-references"},"Type-safe references"),(0,o.kt)("p",null,"Next feature I would like to mention is rather hidden, and is a bit experimental. In MikroORM 4, all EntityManager and EntityRepository methods for querying entities (e.g. find()) will now return special Loaded type, where we automatically infer what relations are populated. It dynamically adds special get() method to both Reference and Collection instances, that you can use to ensure the relation is loaded on the type level."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id: number;\n\n  @ManyToOne(() => Author, { wrappedReference: true })\n  author: IdentifiedReference<Author, 'id'>;\n\n  @ManyToOne(() => Publisher, { wrappedReference: true })\n  publisher: IdentifiedReference<Publisher, 'id'>;\n\n  @ManyToMany(() => BookTag)\n  tags = new Collection<BookTag>(this);\n    \n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// will return `Loaded<Book, 'publisher' | 'tags' >`\nconst book = await orm.em.findOne(Book, 1, { populate: ['publisher', 'tags'] });\n\n// the `Book.publisher.get()` will be available as we explicitly populated that relation\nconsole.log(book.publisher.get().name);\nconsole.log(book.publisher.$.name); // we can also use the `$` alias\n\n// on the other hand, `Book.author` was not populated, so trying to access `get()` will fail to compile\nconsole.log(book.author.get().name); // fails with `TS2339: Property 'get' does not exist on type 'IdentifiedReference'`\n\n// we can also use it on collections\nconsole.log(book.tags.get().map(t => t.name)); // `get()` will return array of items\n")),(0,o.kt)("h3",{id:"querybuilder-improvements"},"QueryBuilder improvements"),(0,o.kt)("p",null,"There have been quite a lot of small adjustments in QueryBuilder, to name a few things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"support for subqueries and qb.ref()"),(0,o.kt)("li",{parentName:"ul"},"using sql snippets with qb.raw()"),(0,o.kt)("li",{parentName:"ul"},"pagination support via subselects (QueryFlag.PAGINATE)"),(0,o.kt)("li",{parentName:"ul"},"update & delete queries with auto-joining")),(0,o.kt)("p",null,"Here are few examples of those features in action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const qb = em.createQueryBuilder(Book);\nqb.update({ price: qb.raw('price + 1') }).where({ uuid: '123' });\n\n// update `book` set `price` = price + 1 where `uuid_pk` = ?'\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// following example assumes that there is a virtual (persist: false) property\n// on `Author` entity named `booksTotal`\n\nconst qb1 = em.createQueryBuilder(Book, 'b');\nqb1.count('b.uuid', true).where({ author: qb1.ref('a.id') });\nconst qb2 = em.createQueryBuilder(Author, 'a');\nqb2.select(['*', qb1.as('Author.booksTotal')]).orderBy({ booksTotal: 'desc' });\n\n// select `a`.*, (select count(distinct `b`.`uuid_pk`) as `count` from `book` as `b` where `b`.`author_id` = `a`.`id`) as `books_total` \n// from `author` as `a` \n// order by `books_total` desc\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// following example assumes that there is a virtual (persist: false) property\n// on `Author` entity named `booksTotal`\n\nconst knex = em.getKnex();\nconst qb1 = em.createQueryBuilder(Book, 'b').count('b.uuid', true).where({ author: knex.ref('a.id') }).getKnexQuery();\nconst qb2 = em.createQueryBuilder(Author, 'a');\nqb2.select('*').withSubQuery(qb1, 'a.booksTotal').where({ 'a.booksTotal': { $in: [1, 2, 3] } });\n\n// select `a`.* \n// from `author` as `a`\n// where (select count(distinct `b`.`uuid_pk`) as `count` from `book` as `b` where `b`.`author_id` = `a`.`id`) in (?, ?, ?)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const qb = em.createQueryBuilder(Publisher);\nqb.update({ name: 'test 123' }).where({ $or: [{ books: { author: 123 } }, { books: { title: 'book' } }] });\n\n// update `publisher` set `name` = ? \n// where `id` in (select `e0`.`id` from (\n//   select distinct `e0`.`id` from `publisher` as `e0` left join `book` as `e1` on `e0`.`id` = `e1`.`publisher_id` where (`e1`.`author_id` = ? or `e1`.`title` = ?)\n// ) as `e0`)\n")),(0,o.kt)("h3",{id:"and-many-many-more"},"And many many more\u2026"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"em.begin/commit/rollback() methods are back"),(0,o.kt)("li",{parentName:"ul"},"using file globs for discovery (","*","*","/","*",".entity.ts)"),(0,o.kt)("li",{parentName:"ul"},"custom driver exceptions (UniqueConstraintViolationException, \u2026)"),(0,o.kt)("li",{parentName:"ul"},"adding items to not-initialized collections"),(0,o.kt)("li",{parentName:"ul"},"bulk deletes and other performance improvements"),(0,o.kt)("li",{parentName:"ul"},"inference of custom repository type (EntityRepositoryType)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/serializing#property-serializers"},"property serializers"))),(0,o.kt)("p",null,"See the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm/blob/master/CHANGELOG.md"},"changelog")," for full list of new features and fixes."),(0,o.kt)("h4",{id:"more-example-integrations"},"More example integrations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Koa: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/koa-ts-example-app"},"https://github.com/mikro-orm/koa-ts-example-app")),(0,o.kt)("li",{parentName:"ul"},"GraphQL: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/driescroons/mikro-orm-graphql-example"},"https://github.com/driescroons/mikro-orm-graphql-example")),(0,o.kt)("li",{parentName:"ul"},"Serverless: ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/thomaschaaf/serverless-mikro-orm-example-app"},"https://github.com/thomaschaaf/serverless-mikro-orm-example-app"))),(0,o.kt)("h3",{id:"upgrading"},"Upgrading"),(0,o.kt)("p",null,"For smooth upgrading, read the full ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/upgrading-v3-to-v4"},"upgrading guide"),". Here are few notable breaking changes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default metadata provider is ReflectMetadataProvider, to use ts-morph, you need to install it from @mikro-orm/reflection and explicitly provide it in the ORM configuration. If you want to use ReflectMetadataProvider, be sure to see the ",(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/metadata-providers/#limitations-and-requirements"},"list of its limitations"),"."),(0,o.kt)("li",{parentName:"ul"},"TsMorphMetadataProvider now uses ","*",".d.ts files in production mode, so be sure to enable them in your tsconfig.json."),(0,o.kt)("li",{parentName:"ul"},"@mikro-orm/core package is not dependent on knex, and therefore cannot provide methods like createQueryBuilder()\u200a\u2014\u200ainstead, those methods exist on SqlEntityManager. You can import it from the driver package, e.g. import { EntityManager } from '@mikro-orm/mysql;."),(0,o.kt)("li",{parentName:"ul"},"To use CLI, you need to install @mikro-orm/cli package."),(0,o.kt)("li",{parentName:"ul"},"When using folder based discovery, the options entitiesDirs and entitiesDirsTs are now removed in favour of entities and entitiesTs. You can now mix entity references with folders and file globs, negative globs are also supported."),(0,o.kt)("li",{parentName:"ul"},"For Nest.js users, there is a new ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/nestjs"},"@mikro-orm/nestjs")," package, which is a fork of the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/dario1985/nestjs-mikro-orm"},"nestjs-mikro-orm")," module with changes needed for",(0,o.kt)("br",{parentName:"li"}),"MikroORM 4.")),(0,o.kt)("h3",{id:"whats-next"},"What\u2019s next?"),(0,o.kt)("p",null,"Here are some features I\u2019d like to work on in the near future:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Improved schema diffing"),(0,o.kt)("li",{parentName:"ul"},"ts-morph reflection via custom TS compiler plugin"),(0,o.kt)("li",{parentName:"ul"},"Query caching"),(0,o.kt)("li",{parentName:"ul"},"MS SQL Server support")),(0,o.kt)("h3",{id:"wdyt"},"WDYT?"),(0,o.kt)("p",null,"So this is MikroORM 4, what do you think about it? What features or changes would you like to see next? Or what part of the documentation should be improved and how?"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Like")," ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/"},(0,o.kt)("em",{parentName:"a"},"MikroORM")),(0,o.kt)("em",{parentName:"p"},"? \u2b50\ufe0f")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm"},(0,o.kt)("em",{parentName:"a"},"Star it"))," ",(0,o.kt)("em",{parentName:"p"},"on GitHub and share this article with your friends. If you want to support the project financially, you can do so via")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sponsors/B4nan"},(0,o.kt)("em",{parentName:"a"},"GitHub Sponsors")),(0,o.kt)("em",{parentName:"p"},"."))))}d.isMDXComponent=!0}}]);