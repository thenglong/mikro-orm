"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[20712],{60231:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"5.3","label":"5.3","banner":null,"badge":true,"noIndex":false,"className":"docs-version-5.3","isLast":true,"docsSidebars":{"docs":[{"type":"category","label":"Overview","items":[{"type":"link","label":"Installation & Usage","href":"/docs/installation","docId":"installation"},{"type":"link","label":"Defining Entities","href":"/docs/defining-entities","docId":"defining-entities"},{"type":"link","label":"Modeling Entity Relationships","href":"/docs/relationships","docId":"relationships"},{"type":"link","label":"Entity Manager","href":"/docs/entity-manager","docId":"entity-manager"},{"type":"link","label":"Unit of Work","href":"/docs/unit-of-work","docId":"unit-of-work"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Fundamentals","items":[{"type":"link","label":"Identity Map","href":"/docs/identity-map","docId":"identity-map"},{"type":"link","label":"Entity References","href":"/docs/entity-references","docId":"entity-references"},{"type":"link","label":"Collections","href":"/docs/collections","docId":"collections"},{"type":"link","label":"Entity Repository","href":"/docs/repositories","docId":"repositories"},{"type":"link","label":"Transactions and Concurrency","href":"/docs/transactions","docId":"transactions"},{"type":"link","label":"Inheritance Mapping","href":"/docs/inheritance-mapping","docId":"inheritance-mapping"},{"type":"link","label":"Cascading","href":"/docs/cascading","docId":"cascading"},{"type":"link","label":"Filters","href":"/docs/filters","docId":"filters"},{"type":"link","label":"Deployment","href":"/docs/deployment","docId":"deployment"},{"type":"link","label":"Using Query Builder","href":"/docs/query-builder","docId":"query-builder"},{"type":"link","label":"Result cache","href":"/docs/caching","docId":"caching"},{"type":"link","label":"Logging","href":"/docs/logging","docId":"logging"}],"collapsed":true,"collapsible":true,"href":"/docs/fundamentals"},{"type":"category","label":"Advanced Features","items":[{"type":"link","label":"Smart Nested Populate","href":"/docs/nested-populate","docId":"nested-populate"},{"type":"link","label":"Smart Query Conditions","href":"/docs/query-conditions","docId":"query-conditions"},{"type":"link","label":"Propagation","href":"/docs/propagation","docId":"propagation"},{"type":"link","label":"Loading Strategies","href":"/docs/loading-strategies","docId":"loading-strategies"},{"type":"link","label":"Serializing","href":"/docs/serializing","docId":"serializing"},{"type":"link","label":"Updating Entity Values","href":"/docs/entity-helper","docId":"entity-helper"},{"type":"link","label":"Events and Hooks","href":"/docs/events","docId":"events"},{"type":"link","label":"Composite Primary Keys","href":"/docs/composite-keys","docId":"composite-keys"},{"type":"link","label":"Custom Types","href":"/docs/custom-types","docId":"custom-types"},{"type":"link","label":"Virtual Entities","href":"/docs/virtual-entities","docId":"virtual-entities"},{"type":"link","label":"Embeddables","href":"/docs/embeddables","docId":"embeddables"},{"type":"link","label":"Defining Entities via EntitySchema","href":"/docs/entity-schema","docId":"entity-schema"},{"type":"link","label":"Using JSON properties","href":"/docs/json-properties","docId":"json-properties"},{"type":"link","label":"Metadata Providers","href":"/docs/metadata-providers","docId":"metadata-providers"},{"type":"link","label":"Metadata Cache","href":"/docs/metadata-cache","docId":"metadata-cache"},{"type":"link","label":"Schema Generator","href":"/docs/schema-generator","docId":"schema-generator"},{"type":"link","label":"Entity Generator","href":"/docs/entity-generator","docId":"entity-generator"},{"type":"link","label":"Naming Strategy","href":"/docs/naming-strategy","docId":"naming-strategy"},{"type":"link","label":"Property Validation","href":"/docs/property-validation","docId":"property-validation"},{"type":"link","label":"Migrations","href":"/docs/migrations","docId":"migrations"},{"type":"link","label":"Seeding","href":"/docs/seeding","docId":"seeding"},{"type":"link","label":"Read Replica Connections","href":"/docs/read-connections","docId":"read-connections"}],"collapsed":true,"collapsible":true,"href":"/docs/advanced"},{"type":"category","label":"Reference","items":[{"type":"link","label":"EntityManager API","href":"/api/next/core/class/EntityManager"},{"type":"link","label":"EntityRepository API","href":"/api/next/core/class/EntityRepository"},{"type":"link","label":"QueryBuilder API","href":"/api/next/knex/class/QueryBuilder"},{"type":"link","label":"Decorators","href":"/docs/decorators","docId":"decorators"},{"type":"link","label":"Configuration","href":"/docs/configuration","docId":"configuration"}],"collapsed":true,"collapsible":true,"href":"/docs/reference"},{"type":"category","label":"Usage with Different Drivers","items":[{"type":"link","label":"Usage with SQL Drivers","href":"/docs/usage-with-sql","docId":"usage-with-sql"},{"type":"link","label":"Usage with MongoDB","href":"/docs/usage-with-mongo","docId":"usage-with-mongo"}],"collapsed":true,"collapsible":true,"href":"/docs/drivers"},{"type":"category","label":"Recipes","items":[{"type":"link","label":"Quick Start","href":"/docs/quick-start","docId":"quick-start"},{"type":"link","label":"Usage with NestJS","href":"/docs/usage-with-nestjs","docId":"usage-with-nestjs"},{"type":"link","label":"Usage with Vanilla JS","href":"/docs/usage-with-js","docId":"usage-with-js"},{"type":"link","label":"Usage with Babel","href":"/docs/usage-with-babel","docId":"usage-with-babel"},{"type":"link","label":"Usage with AdminJS","href":"/docs/usage-with-adminjs","docId":"usage-with-adminjs"},{"type":"link","label":"Using Entity Constructors","href":"/docs/entity-constructors","docId":"entity-constructors"},{"type":"link","label":"Using Multiple Schemas","href":"/docs/multiple-schemas","docId":"multiple-schemas"},{"type":"link","label":"Using native BigInt PKs (MySQL and PostgreSQL)","href":"/docs/using-bigint-pks","docId":"using-bigint-pks"},{"type":"link","label":"Using AsyncLocalStorage","href":"/docs/async-local-storage","docId":"async-local-storage"},{"type":"link","label":"Creating Custom Driver","href":"/docs/custom-driver","docId":"custom-driver"}],"collapsed":true,"collapsible":true,"href":"/docs/recipes"},{"type":"category","label":"Example Integrations","items":[{"type":"link","label":"Express + MongoDB + TypeScript","href":"https://github.com/mikro-orm/express-ts-example-app"},{"type":"link","label":"NestJS + MySQL + TypeScript","href":"https://github.com/mikro-orm/nestjs-example-app"},{"type":"link","label":"RealWorld example app (Nest + MySQL)","href":"https://github.com/mikro-orm/nestjs-realworld-example-app"},{"type":"link","label":"Express + MongoDB + JavaScript","href":"https://github.com/mikro-orm/express-js-example-app"},{"type":"link","label":"Koa + SQLite + TypeScript","href":"https://github.com/mikro-orm/koa-ts-example-app"},{"type":"link","label":"Inversify + PostgreSQL","href":"https://github.com/PodaruDragos/inversify-example-app"},{"type":"link","label":"NextJS + MySQL","href":"https://github.com/jonahallibone/mikro-orm-nextjs"},{"type":"link","label":"GraphQL + PostgreSQL + TypeScript","href":"https://github.com/driescroons/mikro-orm-graphql-example"}],"collapsed":true,"collapsible":true,"href":"/docs/examples"},{"type":"category","label":"Upgrading","items":[{"type":"link","label":"Upgrading from v4 to v5","href":"/docs/upgrading-v4-to-v5","docId":"upgrading-v4-to-v5"},{"type":"link","label":"Upgrading from v3 to v4","href":"/docs/upgrading-v3-to-v4","docId":"upgrading-v3-to-v4"},{"type":"link","label":"Upgrading from v2 to v3","href":"/docs/upgrading-v2-to-v3","docId":"upgrading-v2-to-v3"}],"collapsed":true,"collapsible":true,"href":"/docs/upgrading"}]},"docs":{"async-local-storage":{"id":"async-local-storage","title":"Using AsyncLocalStorage","description":"Since v5 AsyncLocalStorage is used inside RequestContext helper so this section","sidebar":"docs"},"caching":{"id":"caching","title":"Result cache","description":"MikroORM has simple result caching mechanism. It works with those methods of","sidebar":"docs"},"cascading":{"id":"cascading","title":"Cascading persist, merge and remove","description":"From v4.2, cascade merging is no longer configurable (and is kept enabled for all relations).","sidebar":"docs"},"collections":{"id":"collections","title":"Collections","description":"OneToMany and ManyToMany properties are stored in a Collection wrapper.","sidebar":"docs"},"composite-keys":{"id":"composite-keys","title":"Composite and Foreign Keys as Primary Key","description":"Support for composite keys was added in version 3.5","sidebar":"docs"},"configuration":{"id":"configuration","title":"Configuration","description":"Entity Discovery","sidebar":"docs"},"custom-driver":{"id":"custom-driver","title":"Creating Custom Driver","description":"If you want to use database that is not currently supported, you can implement your own driver.","sidebar":"docs"},"custom-types":{"id":"custom-types","title":"Custom Types","description":"You can define custom types by extending Type abstract class. It has several optional methods:","sidebar":"docs"},"decorators":{"id":"decorators","title":"Decorators","description":"Entity Definition","sidebar":"docs"},"defining-entities":{"id":"defining-entities","title":"Defining Entities","description":"Entities are simple javascript objects (so called POJO) without restrictions and without the need to extend base classes. Using entity constructors works as well - they are never executed for managed entities (loaded from database).","sidebar":"docs"},"deployment":{"id":"deployment","title":"Deployment","description":"Under the hood, MikroORM uses ts-morph to read","sidebar":"docs"},"embeddables":{"id":"embeddables","title":"Separating Concerns using Embeddables","description":"Support for embeddables was added in version 4.0","sidebar":"docs"},"entity-constructors":{"id":"entity-constructors","title":"Using Entity Constructors","description":"Internally, MikroORM never calls entity constructor, so you are free to use it as you wish.","sidebar":"docs"},"entity-generator":{"id":"entity-generator","title":"Entity Generator","description":"To generate entities from existing database schema, you can use EntityGenerator helper.","sidebar":"docs"},"entity-helper":{"id":"entity-helper","title":"EntityHelper and Decorated Entities","description":"Updating Entity Values with entity.assign()","sidebar":"docs"},"entity-manager":{"id":"entity-manager","title":"Working with Entity Manager","description":"Persist and Flush","sidebar":"docs"},"entity-references":{"id":"entity-references","title":"Entity References","description":"Every single entity relation is mapped to an entity reference. Reference is an entity that has","sidebar":"docs"},"entity-schema":{"id":"entity-schema","title":"Defining Entities via EntitySchema","description":"With EntitySchema helper we define the schema programmatically.","sidebar":"docs"},"events":{"id":"events","title":"Events and Lifecycle Hooks","description":"There are two ways to hook to the lifecycle of an entity:","sidebar":"docs"},"faq":{"id":"faq","title":"Frequently Asked Questions","description":"How can I synchronize my database schema with the entities?"},"filters":{"id":"filters","title":"Filters","description":"MikroORM has the ability to pre-define filter criteria and attach those filters","sidebar":"docs"},"identity-map":{"id":"identity-map","title":"Identity Map and Request Context","description":"MikroORM uses identity map in background, so we will always get the same instance of one entity.","sidebar":"docs"},"inheritance-mapping":{"id":"inheritance-mapping","title":"Inheritance Mapping","description":"Mapped Superclasses","sidebar":"docs"},"installation":{"id":"installation","title":"Installation & Usage","description":"First install the module via yarn or npm and do not forget to install the","sidebar":"docs"},"json-properties":{"id":"json-properties","title":"Using JSON properties","description":"Defining JSON properties","sidebar":"docs"},"loading-strategies":{"id":"loading-strategies","title":"Relationship Loading Strategies","description":"JOINED loading strategy is SQL only feature.","sidebar":"docs"},"logging":{"id":"logging","title":"Logging","description":"For development purposes it might come handy to enable logging and debug mode:","sidebar":"docs"},"metadata-cache":{"id":"metadata-cache","title":"Metadata Cache","description":"In v4 and later versions, we need to explicitly install @mikro-orm/reflection","sidebar":"docs"},"metadata-providers":{"id":"metadata-providers","title":"Metadata Providers","description":"As part of entity discovery process, MikroORM uses so called MetadataProvider to get necessary","sidebar":"docs"},"migrations":{"id":"migrations","title":"Migrations","description":"To use migrations we need to first install @mikro-orm/migrations package for SQL driver or @mikro-orm/migrations-mongodb for MongoDB.","sidebar":"docs"},"multiple-schemas":{"id":"multiple-schemas","title":"Using Multiple Schemas","description":"In MySQL and PostgreSQL it is possible to define your entities in multiple schemas. In MySQL","sidebar":"docs"},"naming-strategy":{"id":"naming-strategy","title":"Naming Strategy","description":"When mapping our entities to database tables and columns, their names will be defined by naming","sidebar":"docs"},"nested-populate":{"id":"nested-populate","title":"Smart Nested Populate","description":"MikroORM is capable of loading large nested structures while maintaining good","sidebar":"docs"},"propagation":{"id":"propagation","title":"Propagation","description":"By default, MikroORM will propagate all changes made to one side of bi-directional relations to the other side, keeping them in sync. This works for all relations, including M1. As part of","sidebar":"docs"},"property-validation":{"id":"property-validation","title":"Property Validation","description":"Required properties","sidebar":"docs"},"query-builder":{"id":"query-builder","title":"Using Query Builder","description":"or EntityRepository to have access to createQueryBuilder() method.","sidebar":"docs"},"query-conditions":{"id":"query-conditions","title":"Smart Query Conditions","description":"When you want to make complex queries, we can easily end up with a lot of boilerplate code","sidebar":"docs"},"quick-start":{"id":"quick-start","title":"Quick Start","description":"First install the module via yarn or npm and do not forget to install the","sidebar":"docs"},"read-connections":{"id":"read-connections","title":"Read Replica Connections","description":"Users can specify multiple read connections via replicas option. You can provide only fields","sidebar":"docs"},"relationships":{"id":"relationships","title":"Modeling Entity Relationships","description":"There are 4 types of entity relationships in MikroORM:","sidebar":"docs"},"repositories":{"id":"repositories","title":"Using EntityRepository instead of EntityManager","description":"Entity Repositories are thin layers on top of EntityManager. They act as an","sidebar":"docs"},"schema-generator":{"id":"schema-generator","title":"Schema Generator","description":"SchemaGenerator can do harm to your database. It will drop or alter tables, indexes,","sidebar":"docs"},"seeding":{"id":"seeding","title":"Seeding","description":"When initializing your application or testing it can be exhausting to create sample data for your database. The solution is to use seeding. Create factories for your entities and use them in the seed","sidebar":"docs"},"serializing":{"id":"serializing","title":"Serializing","description":"By default, all entities are monkey patched with toObject() and toJSON methods:","sidebar":"docs"},"transactions":{"id":"transactions","title":"Transactions and Concurrency","description":"Starting v3.4, transactions are also supported in MongoDB driver.","sidebar":"docs"},"unit-of-work":{"id":"unit-of-work","title":"Unit of Work and Transactions","description":"MikroORM uses the Identity Map pattern to track objects. Whenever you fetch an object from","sidebar":"docs"},"upgrading-v2-to-v3":{"id":"upgrading-v2-to-v3","title":"Upgrading from v2 to v3","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid","sidebar":"docs"},"upgrading-v3-to-v4":{"id":"upgrading-v3-to-v4","title":"Upgrading from v3 to v4","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid","sidebar":"docs"},"upgrading-v4-to-v5":{"id":"upgrading-v4-to-v5","title":"Upgrading from v4 to v5","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid","sidebar":"docs"},"usage-with-adminjs":{"id":"usage-with-adminjs","title":"Using MikroORM with AdminJS","description":"Installation","sidebar":"docs"},"usage-with-babel":{"id":"usage-with-babel","title":"Usage with Babel","description":"When compiling TS via babel, decorators are by default handled different implementation","sidebar":"docs"},"usage-with-js":{"id":"usage-with-js","title":"Usage with JavaScript","description":"Since MikroORM 3.2, we can use EntitySchema helper to define own entities without decorators, which works also for Vanilla JavaScript.","sidebar":"docs"},"usage-with-mongo":{"id":"usage-with-mongo","title":"Usage with MongoDB","description":"To use MikroORM with mongo database, do not forget to install @mikro-orm/mongodb","sidebar":"docs"},"usage-with-nestjs":{"id":"usage-with-nestjs","title":"Using MikroORM with NestJS framework","description":"Installation","sidebar":"docs"},"usage-with-sql":{"id":"usage-with-sql","title":"Usage with MySQL, MariaDB, PostgreSQL or SQLite","description":"To use mikro-orm with MySQL database, simply install the @mikro-orm/mysql dependency and set","sidebar":"docs"},"using-bigint-pks":{"id":"using-bigint-pks","title":"Using native BigInt PKs (MySQL and PostgreSQL)","description":"We can use BigIntType to support bigints. By default, it will represent the value as","sidebar":"docs"},"virtual-entities":{"id":"virtual-entities","title":"Virtual Entities","description":"Virtual entities don\'t represent any database table. Instead, they dynamically resolve to an SQL query (or an aggregation in mongo), allowing to map any kind of results onto an entity. Such entities are mean for read purposes, they don\'t have a primary key and therefore cannot be tracked for changes. In a sense they are similar to (currently unsupported) database views.","sidebar":"docs"}}}')}}]);