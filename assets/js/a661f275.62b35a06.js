"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[86198],{6053:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"3.6","label":"3.6","banner":"unmaintained","badge":true,"noIndex":false,"className":"docs-version-3.6","isLast":false,"docsSidebars":{"version-3.6/docs":[{"type":"category","label":"Overview","items":[{"type":"link","label":"Installation & Usage","href":"/docs/3.6/installation","docId":"installation"},{"type":"link","label":"Defining Entities","href":"/docs/3.6/defining-entities","docId":"defining-entities"},{"type":"link","label":"Modeling Entity Relationships","href":"/docs/3.6/relationships","docId":"relationships"},{"type":"link","label":"Entity Manager","href":"/docs/3.6/entity-manager","docId":"entity-manager"},{"type":"link","label":"Entity Repository","href":"/docs/3.6/repositories","docId":"repositories"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Fundamentals","items":[{"type":"link","label":"Identity Map and Request Context","href":"/docs/3.6/identity-map","docId":"identity-map"},{"type":"link","label":"Entity References and Reference<T> Wrapper","href":"/docs/3.6/entity-references","docId":"entity-references"},{"type":"link","label":"Using Entity Constructors","href":"/docs/3.6/entity-constructors","docId":"entity-constructors"},{"type":"link","label":"Collections","href":"/docs/3.6/collections","docId":"collections"},{"type":"link","label":"Unit of Work","href":"/docs/3.6/unit-of-work","docId":"unit-of-work"},{"type":"link","label":"Transactions and Concurrency","href":"/docs/3.6/transactions","docId":"transactions"},{"type":"link","label":"Cascading","href":"/docs/3.6/cascading","docId":"cascading"},{"type":"link","label":"Composite Primary Keys","href":"/docs/3.6/composite-keys","docId":"composite-keys"},{"type":"link","label":"Deployment","href":"/docs/3.6/deployment","docId":"deployment"},{"type":"link","label":"Decorators Reference","href":"/docs/3.6/decorators","docId":"decorators"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Advanced Features","items":[{"type":"link","label":"Smart Nested Populate","href":"/docs/3.6/nested-populate","docId":"nested-populate"},{"type":"link","label":"Smart Query Conditions","href":"/docs/3.6/query-conditions","docId":"query-conditions"},{"type":"link","label":"Using Query Builder","href":"/docs/3.6/query-builder","docId":"query-builder"},{"type":"link","label":"Propagation","href":"/docs/3.6/propagation","docId":"propagation"},{"type":"link","label":"Serializing","href":"/docs/3.6/serializing","docId":"serializing"},{"type":"link","label":"Updating Entity Values","href":"/docs/3.6/entity-helper","docId":"entity-helper"},{"type":"link","label":"Property Validation","href":"/docs/3.6/property-validation","docId":"property-validation"},{"type":"link","label":"Lifecycle Hooks","href":"/docs/3.6/lifecycle-hooks","docId":"lifecycle-hooks"},{"type":"link","label":"Naming Strategy","href":"/docs/3.6/naming-strategy","docId":"naming-strategy"},{"type":"link","label":"Custom Types","href":"/docs/3.6/custom-types","docId":"custom-types"},{"type":"link","label":"Defining Entities via EntitySchema","href":"/docs/3.6/entity-schema","docId":"entity-schema"},{"type":"link","label":"Metadata Providers","href":"/docs/3.6/metadata-providers","docId":"metadata-providers"},{"type":"link","label":"Metadata Cache","href":"/docs/3.6/metadata-cache","docId":"metadata-cache"},{"type":"link","label":"Debugging","href":"/docs/3.6/debugging","docId":"debugging"},{"type":"link","label":"Schema Generator","href":"/docs/3.6/schema-generator","docId":"schema-generator"},{"type":"link","label":"Entity Generator","href":"/docs/3.6/entity-generator","docId":"entity-generator"},{"type":"link","label":"Migrations","href":"/docs/3.6/migrations","docId":"migrations"},{"type":"link","label":"Read Replica Connections","href":"/docs/3.6/read-connections","docId":"read-connections"},{"type":"link","label":"Advanced Configuration","href":"/docs/3.6/configuration","docId":"configuration"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Usage with Different Drivers","items":[{"type":"link","label":"Usage with SQL Drivers","href":"/docs/3.6/usage-with-sql","docId":"usage-with-sql"},{"type":"link","label":"Usage with MongoDB","href":"/docs/3.6/usage-with-mongo","docId":"usage-with-mongo"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Recipes","items":[{"type":"link","label":"Usage with NestJS","href":"/docs/3.6/usage-with-nestjs","docId":"usage-with-nestjs"},{"type":"link","label":"Usage with Vanilla JS","href":"/docs/3.6/usage-with-js","docId":"usage-with-js"},{"type":"link","label":"Creating Custom Driver","href":"/docs/3.6/custom-driver","docId":"custom-driver"},{"type":"link","label":"Using Multiple Schemas","href":"/docs/3.6/multiple-schemas","docId":"multiple-schemas"},{"type":"link","label":"Using native BigInt PKs (MySQL and PostgreSQL)","href":"/docs/3.6/using-bigint-pks","docId":"using-bigint-pks"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Example Integrations","items":[{"type":"link","label":"Express + MongoDB + TypeScript","href":"https://github.com/mikro-orm/express-ts-example-app"},{"type":"link","label":"NestJS + MySQL + TypeScript","href":"https://github.com/mikro-orm/nestjs-example-app"},{"type":"link","label":"RealWorld example app (Nest + MySQL)","href":"https://github.com/mikro-orm/nestjs-realworld-example-app"},{"type":"link","label":"Express + MongoDB + JavaScript","href":"https://github.com/mikro-orm/express-js-example-app"}],"collapsed":true,"collapsible":true}]},"docs":{"cascading":{"id":"cascading","title":"Cascading persist, merge and remove","description":"When persisting or removing entity, all your references are by default cascade persisted.","sidebar":"version-3.6/docs"},"collections":{"id":"collections","title":"Collections","description":"OneToMany and ManyToMany collections are stored in a Collection wrapper. It implements","sidebar":"version-3.6/docs"},"composite-keys":{"id":"composite-keys","title":"Composite and Foreign Keys as Primary Key","description":"Support for composite keys was added in version 3.5","sidebar":"version-3.6/docs"},"configuration":{"id":"configuration","title":"Advanced Configuration","description":"Entity Discovery","sidebar":"version-3.6/docs"},"custom-driver":{"id":"custom-driver","title":"Creating Custom Driver","description":"If you want to use database that is not currently supported, you can implement your own driver.","sidebar":"version-3.6/docs"},"custom-types":{"id":"custom-types","title":"Custom Types","description":"You can define custom types by extending Type abstract class. It has 4 optional methods:","sidebar":"version-3.6/docs"},"debugging":{"id":"debugging","title":"Debugging","description":"For development purposes it might come handy to enable logging and debug mode:","sidebar":"version-3.6/docs"},"decorators":{"id":"decorators","title":"Decorators Reference","description":"Entity Definition","sidebar":"version-3.6/docs"},"defining-entities":{"id":"defining-entities","title":"Defining Entities","description":"There are two ways how you can define your entities:","sidebar":"version-3.6/docs"},"deployment":{"id":"deployment","title":"Deployment","description":"Under the hood, MikroORM uses ts-morph to read","sidebar":"version-3.6/docs"},"entity-constructors":{"id":"entity-constructors","title":"Using Entity Constructors","description":"Internally, MikroORM never calls entity constructor, so you are free to use it as you wish.","sidebar":"version-3.6/docs"},"entity-generator":{"id":"entity-generator","title":"Entity Generator","description":"To generate entities from existing database schema, you can use EntityGenerator helper.","sidebar":"version-3.6/docs"},"entity-helper":{"id":"entity-helper","title":"EntityHelper and Decorated Entities","description":"Updating Entity Values with entity.assign()","sidebar":"version-3.6/docs"},"entity-manager":{"id":"entity-manager","title":"Working with Entity Manager","description":"Persist and Flush","sidebar":"version-3.6/docs"},"entity-references":{"id":"entity-references","title":"Entity References","description":"Every single entity relation is mapped to an entity reference. Reference is an entity that has","sidebar":"version-3.6/docs"},"entity-schema":{"id":"entity-schema","title":"Defining Entities via EntitySchema","description":"With EntitySchema helper you define the schema programmatically.","sidebar":"version-3.6/docs"},"identity-map":{"id":"identity-map","title":"Identity Map and Request Context","description":"MikroORM uses identity map in background so you will always get the same instance of","sidebar":"version-3.6/docs"},"index":{"id":"index","title":"MikroORM v3","description":"Table of contents"},"installation":{"id":"installation","title":"Installation & Usage","description":"First install the module via yarn or npm and do not forget to install the database driver as well:","sidebar":"version-3.6/docs"},"lifecycle-hooks":{"id":"lifecycle-hooks","title":"Lifecycle Hooks","description":"You can use lifecycle hooks to run some code when entity gets persisted. You can mark any of","sidebar":"version-3.6/docs"},"metadata-cache":{"id":"metadata-cache","title":"Metadata Cache","description":"Under the hood, MikroORM uses ts-morph to read","sidebar":"version-3.6/docs"},"metadata-providers":{"id":"metadata-providers","title":"Metadata Providers","description":"As part of entity discovery process, MikroORM uses so called MetadataProvider to get necessary","sidebar":"version-3.6/docs"},"migrations":{"id":"migrations","title":"Migrations","description":"MikroORM has integrated support for migrations via umzug.","sidebar":"version-3.6/docs"},"multiple-schemas":{"id":"multiple-schemas","title":"Using Multiple Schemas","description":"In MySQL and PostgreSQL it is possible to define your entities in multiple schemas. In MySQL","sidebar":"version-3.6/docs"},"naming-strategy":{"id":"naming-strategy","title":"Naming Strategy","description":"When mapping your entities to database tables and columns, their names will be defined by naming","sidebar":"version-3.6/docs"},"nested-populate":{"id":"nested-populate","title":"Smart Nested Populate","description":"MikroORM is capable of loading large nested structures while maintaining good","sidebar":"version-3.6/docs"},"propagation":{"id":"propagation","title":"Propagation","description":"By default MikroORM will propagate all changes made to one side of bi-directional relations","sidebar":"version-3.6/docs"},"property-validation":{"id":"property-validation","title":"Property Validation","description":"MikroORM will validate your properties before actual persisting happens. It will try to fix wrong","sidebar":"version-3.6/docs"},"query-builder":{"id":"query-builder","title":"Using Query Builder","description":"When you need to execute some SQL query without all the ORM stuff involved, you can either","sidebar":"version-3.6/docs"},"query-conditions":{"id":"query-conditions","title":"Smart Query Conditions","description":"When you want to make complex queries, you can easily end up with a lot of boilerplate code","sidebar":"version-3.6/docs"},"read-connections":{"id":"read-connections","title":"Read Replica Connections","description":"Users can specify multiple read connections via replicas option. You can provide only fields","sidebar":"version-3.6/docs"},"relationships":{"id":"relationships","title":"Modeling Entity Relationships","description":"There are 4 types of entity relationships in MikroORM:","sidebar":"version-3.6/docs"},"repositories":{"id":"repositories","title":"Using EntityRepository instead of EntityManager","description":"More convenient way of fetching entities from database is by using EntityRepository, that","sidebar":"version-3.6/docs"},"schema-generator":{"id":"schema-generator","title":"Schema Generator","description":"SchemaGenerator can do harm to your database. It will drop or alter tables, indexes,","sidebar":"version-3.6/docs"},"serializing":{"id":"serializing","title":"Serializing","description":"By default, all entities are monkey patched with toObject() and toJSON methods:","sidebar":"version-3.6/docs"},"transactions":{"id":"transactions","title":"Transactions and Concurrency","description":"Starting v3.4, transactions are also supported in MongoDB driver.","sidebar":"version-3.6/docs"},"unit-of-work":{"id":"unit-of-work","title":"Unit of Work and Transactions","description":"MikroORM uses the Identity Map pattern to track objects. Whenever you fetch an object from","sidebar":"version-3.6/docs"},"upgrading-v2-to-v3":{"id":"upgrading-v2-to-v3","title":"Upgrading from v2 to v3","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid"},"upgrading-v3-to-v4":{"id":"upgrading-v3-to-v4","title":"Upgrading from v3 to v4","description":"Following sections describe (hopefully) all breaking changes, most of them might be not valid"},"usage-with-js":{"id":"usage-with-js","title":"Usage with JavaScript","description":"Since MikroORM 3.2, we can use EntitySchema helper to define own entities without","sidebar":"version-3.6/docs"},"usage-with-mongo":{"id":"usage-with-mongo","title":"Usage with MongoDB","description":"To use mikro-orm with mongo database, do not forget to install mongodb dependency. As MongoDriver","sidebar":"version-3.6/docs"},"usage-with-nestjs":{"id":"usage-with-nestjs","title":"Using MikroORM with NestJS framework","description":"Installation","sidebar":"version-3.6/docs"},"usage-with-sql":{"id":"usage-with-sql","title":"Usage with MySQL, MariaDB, PostgreSQL or SQLite","description":"To use mikro-orm with MySQL database, do not forget to install mysql2 dependency and set","sidebar":"version-3.6/docs"},"using-bigint-pks":{"id":"using-bigint-pks","title":"Using native BigInt PKs (MySQL and PostgreSQL)","description":"You can use BigIntType to support bigints. By default it will represent the value as","sidebar":"version-3.6/docs"}}}')}}]);